<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Giant Minty Blob (WebGPU)</title>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght=400;700;800;900&display=swap" rel="stylesheet">
    <style>
        :root { --color-mint: #6BCB77; --bg-cloud: #F0F4F8; }
        body { margin: 0; overflow: hidden; background: var(--bg-cloud); touch-action: none; font-family: 'Nunito', sans-serif; }
        
        #game-container { position: relative; width: 100vw; height: 100vh; }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #gpuCanvas { z-index: 1; }
        #uiCanvas { z-index: 2; cursor: grab; }
        
        #error-msg {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: white; padding: 20px; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            font-family: sans-serif; text-align: center; max-width: 80%; z-index: 999;
        }
    </style>
</head>
<body>

    <div id="error-msg">
        <h3 style="color:red">WebGPU Not Working</h3>
        <p id="error-text">Initializing...</p>
    </div>

    <div id="game-container">
        <canvas id="gpuCanvas"></canvas>
        <canvas id="uiCanvas"></canvas>
    </div>

    <script>
        // --- WEBGPU SHADER ---
        const slimeShaderCode = `
            struct Uniforms { resolution: vec2f, color: vec3f, stress: f32, time: f32 };
            @group(0) @binding(0) var<uniform> uniforms: Uniforms;
            @group(0) @binding(1) var<storage, read> points: array<vec2f>;

            struct VertexOutput { @builtin(position) position: vec4f, @location(0) uv: vec2f };

            @vertex fn vs_main(@builtin(vertex_index) vi: u32) -> VertexOutput {
                var pos = array<vec2f, 6>(vec2f(-1,-1), vec2f(1,-1), vec2f(-1,1), vec2f(-1,1), vec2f(1,-1), vec2f(1,1));
                var out: VertexOutput;
                out.position = vec4f(pos[vi], 0.0, 1.0);
                out.uv = pos[vi] * 0.5 + 0.5; out.uv.y = 1.0 - out.uv.y;
                return out;
            }

            fn smin(a: f32, b: f32, k: f32) -> f32 {
                let h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
                return mix(b, a, h) - k * h * (1.0 - h);
            }

            @fragment fn fs_main(@location(0) uv: vec2f) -> @location(0) vec4f {
                let coord = uv * uniforms.resolution;
                var d: f32 = 10000.0;
                let numPoints = arrayLength(&points);
                
                for (var i: u32 = 0; i < numPoints; i++) {
                    let p = points[i];
                    var r = 25.0; if (i >= 60) { r = 70.0; } // Larger Drips
                    d = smin(d, distance(coord, p) - r, 60.0);
                }

                let alpha = 1.0 - smoothstep(0.0, 2.0, d);
                if (alpha < 0.01) { discard; }

                var col = uniforms.color;
                col = mix(col, vec3f(0.8, 0.2, 0.2), uniforms.stress * 0.8);
                let depth = clamp(-d / 100.0, 0.0, 1.0);
                col = mix(col * 0.9, col * 1.3, depth);

                return vec4f(col, alpha);
            }
        `;

        // --- ENGINE ---
        const POINTS = 60, DRIPS = 6, TOTAL = 66;
        let device, context, pipeline, bindGroup, uBuffer, pBuffer;
        let width, height;
        let points = [], pData = new Float32Array(TOTAL * 2);
        let drag = null, mx = 0, my = 0, stress = 0;

        async function init() {
            const errDiv = document.getElementById('error-msg');
            const errText = document.getElementById('error-text');

            if (!navigator.gpu) {
                errDiv.style.display = 'block';
                errText.innerHTML = "WebGPU not found.<br>1. Check Settings > Safari > Advanced > Feature Flags > WebGPU.<br>2. Ensure this is HTTPS (not file://).";
                return;
            }

            try {
                const adapter = await navigator.gpu.requestAdapter();
                if (!adapter) throw new Error("No Adapter found.");
                device = await adapter.requestDevice();
            } catch (e) {
                errDiv.style.display = 'block';
                errText.innerHTML = "WebGPU Request Failed: " + e.message;
                return;
            }

            const canvas = document.getElementById('gpuCanvas');
            context = canvas.getContext('webgpu');
            const format = navigator.gpu.getPreferredCanvasFormat();
            context.configure({ device, format, alphaMode: 'premultiplied' });

            const module = device.createShaderModule({ code: slimeShaderCode });
            pipeline = device.createRenderPipeline({
                layout: 'auto',
                vertex: { module, entryPoint: 'vs_main' },
                fragment: { module, entryPoint: 'fs_main', targets: [{ format }] }
            });

            // Uniforms: Res(2), Color(3), Stress(1), Time(1), Pad(1) -> 8 floats = 32 bytes
            uBuffer = device.createBuffer({ size: 48, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
            pBuffer = device.createBuffer({ size: pData.byteLength, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });

            bindGroup = device.createBindGroup({
                layout: pipeline.getBindGroupLayout(0),
                entries: [{ binding: 0, resource: { buffer: uBuffer } }, { binding: 1, resource: { buffer: pBuffer } }]
            });

            initPoints();
            resize();
            requestAnimationFrame(loop);
        }

        function initPoints() {
            points = [];
            // Main Blob
            for(let i=0; i<POINTS; i++) {
                let a = (Math.PI*2*i)/POINTS;
                let r = 160 + (Math.sin(a)>0 ? Math.sin(a)*80 : 0);
                points.push({ x:0, y:0, ox:0, oy:0, hx: Math.cos(a)*r, hy: Math.sin(a)*r*0.9, drip: false });
            }
            // Drips
            for(let i=0; i<DRIPS; i++) {
                points.push({ x:0, y:0, ox:0, oy:0, hx: (Math.random()-0.5)*500, hy: (Math.random()-0.5)*500 + 300, drip: true });
            }
        }

        function resize() {
            width = window.innerWidth; height = window.innerHeight;
            document.getElementById('gpuCanvas').width = width;
            document.getElementById('gpuCanvas').height = height;
            document.getElementById('uiCanvas').width = width;
            document.getElementById('uiCanvas').height = height;
            
            let cx = width/2, cy = height/2;
            points.forEach(p => { p.x = cx + p.hx; p.y = cy + p.hy; p.ox = p.x; p.oy = p.y; });
        }

        function loop() {
            // Physics
            let cx = width/2, cy = height/2;
            let avgX = 0, avgY = 0;

            points.forEach((p, i) => {
                // Verlet
                let vx = (p.x - p.ox) * 0.92, vy = (p.y - p.oy) * 0.92;
                p.ox = p.x; p.oy = p.y;
                p.x += vx; p.y += vy;

                // Drag
                if (drag === p) { p.x = mx; p.y = my; }
                else {
                    // Home Force
                    let tx = cx + p.hx, ty = cy + p.hy;
                    if (p.drip) { ty += Math.sin(Date.now()*0.002+i)*40; } // Float
                    p.x += (tx - p.x) * (p.drip ? 0.01 : 0.05);
                    p.y += (ty - p.y) * (p.drip ? 0.01 : 0.05);
                }
                
                if (!p.drip) { avgX += p.x; avgY += p.y; }
                
                // Write to GPU Array
                pData[i*2] = p.x; pData[i*2+1] = p.y;
            });

            // Constraints (Blob Only)
            avgX /= POINTS; avgY /= POINTS;
            if(drag && !drag.drip) {
                 stress = Math.min(1, Math.hypot(drag.x - avgX, drag.y - avgY) / 400); 
            } else { stress *= 0.95; }

            for(let k=0; k<4; k++) {
                for(let i=0; i<POINTS; i++) {
                    let p1 = points[i], p2 = points[(i+1)%POINTS];
                    let dx = p2.x - p1.x, dy = p2.y - p1.y;
                    let d = Math.hypot(dx, dy), diff = (20 - d)/d/2; // Approx dist
                    if(p1!==drag) { p1.x -= dx*diff; p1.y -= dy*diff; }
                    if(p2!==drag) { p2.x += dx*diff; p2.y += dy*diff; }
                }
            }

            // Draw UI
            const ctx = document.getElementById('uiCanvas').getContext('2d');
            ctx.clearRect(0,0,width,height);
            ctx.fillStyle = "#2D3436";
            
            // Eyes
            let eyeY = avgY - 40;
            ctx.beginPath();
            ctx.arc(avgX - 50, eyeY, 15, 0, 7);
            ctx.arc(avgX + 50, eyeY, 15, 0, 7);
            ctx.fill();
            
            // Mouth
            ctx.beginPath();
            if (stress > 0.3) { ctx.arc(avgX, eyeY + 60, 20 + stress*20, 0, 7); } // O Face
            else { ctx.arc(avgX, eyeY + 50, 25, 0, 3.14); } // Smile
            ctx.fill();

            // Render GPU
            device.queue.writeBuffer(pBuffer, 0, pData);
            device.queue.writeBuffer(uBuffer, 0, new Float32Array([width, height, 0.42, 0.8, 0.46, stress, 0, 0]));
            
            const enc = device.createCommandEncoder();
            const pass = enc.beginRenderPass({
                colorAttachments: [{ view: context.getCurrentTexture().createView(), loadOp: 'clear', storeOp: 'store', clearValue: {r:0,g:0,b:0,a:0} }]
            });
            pass.setPipeline(pipeline);
            pass.setBindGroup(0, bindGroup);
            pass.draw(6);
            pass.end();
            device.queue.submit([enc.finish()]);

            requestAnimationFrame(loop);
        }

        // Input
        window.onresize = resize;
        const start = (x,y) => {
            mx=x; my=y;
            let closest = null, dist = 100;
            points.forEach(p => { let d = Math.hypot(p.x-x, p.y-y); if(d<dist){dist=d; closest=p;} });
            if(closest) drag = closest;
        };
        window.onmousedown = e => start(e.clientX, e.clientY);
        window.onmousemove = e => { mx=e.clientX; my=e.clientY; };
        window.onmouseup = () => drag = null;
        window.ontouchstart = e => { e.preventDefault(); start(e.touches[0].clientX, e.touches[0].clientY); };
        window.ontouchmove = e => { e.preventDefault(); mx=e.touches[0].clientX; my=e.touches[0].clientY; };
        window.ontouchend = () => drag = null;

        init();
    </script>
</body>
</html>
