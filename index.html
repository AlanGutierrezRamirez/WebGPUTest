<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Giant Minty Blob (WebGL Edition)</title>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght=400;700;800;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-cloud: #F0F4F8;
            --color-mint: #6BCB77; 
            --text-dark: #2D3436;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-cloud);
            /* Static background pattern */
            background-image: radial-gradient(#DDE1E7 15%, transparent 16%);
            background-size: 20px 20px;
            font-family: 'Nunito', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; /* Critical for iPad performance */
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        /* Layer 1: WebGL Canvas (The Gooey Body) */
        canvas#glCanvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
        }

        /* Layer 2: 2D Canvas (The Face & Eyes) */
        canvas#uiCanvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 2;
            cursor: grab;
        }
        canvas#uiCanvas:active {
            cursor: grabbing;
        }

        /* Pause Button */
        .pause-btn {
            position: absolute; top: 20px; right: 20px; z-index: 100;
            width: 50px; height: 50px; border-radius: 50%;
            background: white; border: none;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            display: flex; align-items: center; justify-content: center;
            cursor: pointer;
            transition: transform 0.1s;
        }
        .pause-btn:active { transform: scale(0.95); }
        .pause-btn svg { width: 24px; height: 24px; fill: #2D3436; }

    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="glCanvas"></canvas>
        <canvas id="uiCanvas"></canvas>
    </div>

    <button class="pause-btn" onclick="location.reload()">
        <svg viewBox="0 0 24 24"><path d="M12 5V19M5 12H19" stroke="#2D3436" stroke-width="3" stroke-linecap="round"/></svg>
    </button>

    <script>
        // --- CONFIGURATION ---
        const POINTS = 60;        // Resolution of the main blob
        const DRIPS = 6;          // Number of background drips
        const TOTAL_POINTS = POINTS + DRIPS;
        
        const HEAD_RADIUS = 160;
        const VISCOSITY = 0.92;   // "Jiggle" damping
        const ELASTICITY = 0.05;  // Snap back force

        // --- PHYSICS STATE ---
        const points = [];
        let width, height, centerX, centerY;
        let isDragging = false, dragPoint = null;
        let mouseX = 0, mouseY = 0;
        let currentStress = 0;
        let wobbleTimer = 0;

        // --- WEBGL SHADERS ---
        
        // 1. Vertex Shader (Draws a simple rectangle over the screen)
        const vsSource = `
            attribute vec2 a_position;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

        // 2. Fragment Shader (Calculates the "Goo" math per pixel)
        const fsSource = `
            precision mediump float;
            
            uniform vec2 u_resolution;
            uniform vec2 u_points[${TOTAL_POINTS}]; // Array of all point positions
            uniform float u_stress;
            
            // "Smooth Minimum" function - blends shapes together like liquid
            float smin(float a, float b, float k) {
                float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
                return mix(b, a, h) - k * h * (1.0 - h);
            }

            void main() {
                // Fix coordinates (WebGL 0,0 is bottom-left, we want top-left)
                vec2 uv = gl_FragCoord.xy;
                uv.y = u_resolution.y - uv.y;

                float d = 10000.0;
                
                // Check distance to every point
                for (int i = 0; i < ${TOTAL_POINTS}; i++) {
                    float dist = distance(uv, u_points[i]);
                    
                    // Main blob points are smaller, Drips (last 6) are bigger
                    float radius = (i >= ${POINTS}) ? 70.0 : 25.0; 
                    
                    // Blend them! 60.0 is the "Goo Factor"
                    d = smin(d, dist - radius, 60.0);
                }

                // Hard edge cutoff
                float alpha = 1.0 - smoothstep(0.0, 2.0, d);
                
                if (alpha < 0.1) discard; // Transparent background

                // Colors
                vec3 mint = vec3(0.42, 0.8, 0.47);   // #6BCB77
                vec3 red  = vec3(0.8, 0.36, 0.36);   // Stress Color

                // Mix color based on stress
                vec3 color = mix(mint, red, u_stress * 0.8);

                // Fake 3D lighting (darker edges, lighter center)
                float depth = clamp(-d / 100.0, 0.0, 1.0); 
                color = mix(color * 0.8, color * 1.2, depth);

                // Dark outline
                float outline = smoothstep(-4.0, 0.0, d);
                color = mix(color, color * 0.6, outline);

                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // --- INITIALIZATION ---

        const glCanvas = document.getElementById('glCanvas');
        const uiCanvas = document.getElementById('uiCanvas');
        const gl = glCanvas.getContext('webgl');
        const uiCtx = uiCanvas.getContext('2d');

        // Compile Shader Helper
        function createShader(gl, type, source) {
            const s = gl.createShader(type);
            gl.shaderSource(s, source);
            gl.compileShader(s);
            if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(s));
                return null;
            }
            return s;
        }

        // Setup WebGL Program
        const program = gl.createProgram();
        gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vsSource));
        gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fsSource));
        gl.linkProgram(program);
        gl.useProgram(program);

        // Look up variable locations
        const posLoc = gl.getAttribLocation(program, "a_position");
        const resLoc = gl.getUniformLocation(program, "u_resolution");
        const ptsLoc = gl.getUniformLocation(program, "u_points");
        const strLoc = gl.getUniformLocation(program, "u_stress");

        // Create a screen-filling rectangle
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1,  1, -1,  -1, 1,
            -1, 1,   1, -1,   1, 1
        ]), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);


        // --- PHYSICS LOGIC ---

        function initPoints() {
            width = window.innerWidth;
            height = window.innerHeight;
            centerX = width / 2;
            centerY = height / 2;
            points.length = 0;

            // 1. Main Blob Ring
            for (let i = 0; i < POINTS; i++) {
                const a = (Math.PI * 2 * i) / POINTS;
                let r = HEAD_RADIUS;
                // Add uneven shape
                if (Math.sin(a) > 0) r += Math.sin(a)*40 + Math.sin(a*5)*10;

                const hx = Math.cos(a) * r;
                const hy = Math.sin(a) * r * 0.9;
                
                points.push({
                    x: centerX + hx, y: centerY + hy,
                    ox: centerX + hx, oy: centerY + hy, // old position (for velocity)
                    hx: hx, hy: hy, // home position (relative to center)
                    drip: false
                });
            }

            // 2. Background Drips
            for(let i = 0; i < DRIPS; i++) {
                // Random positions
                const rx = (Math.random() - 0.5) * width;
                const ry = (Math.random() - 0.5) * height;
                points.push({
                    x: centerX + rx, y: centerY + ry,
                    ox: centerX + rx, oy: centerY + ry,
                    hx: rx, hy: ry,
                    drip: true
                });
            }
        }

        function updatePhysics() {
            if (wobbleTimer > 0) wobbleTimer--;

            // Calculate Blob Center
            let avgX = 0, avgY = 0;
            for(let i=0; i<POINTS; i++) { avgX += points[i].x; avgY += points[i].y; }
            avgX /= POINTS; avgY /= POINTS;

            // Stress Calculation
            if(isDragging && dragPoint && !dragPoint.drip) {
                const d = Math.hypot(dragPoint.x - avgX, dragPoint.y - avgY);
                currentStress = Math.min(1, Math.max(0, (d - 160) / 150));
            } else {
                currentStress *= 0.95; // Decay
            }

            // Point Physics
            for(let i=0; i<TOTAL_POINTS; i++) {
                let p = points[i];

                if(p === dragPoint) {
                    p.x = mouseX; p.y = mouseY;
                    p.ox = p.x; p.oy = p.y;
                } else {
                    // Verlet Integration (Inertia)
                    let vx = (p.x - p.ox) * VISCOSITY;
                    let vy = (p.y - p.oy) * VISCOSITY;
                    p.ox = p.x; p.oy = p.y;
                    p.x += vx; p.y += vy;

                    // Spring to Home
                    let tx = centerX + p.hx;
                    let ty = centerY + p.hy;
                    
                    if(p.drip) {
                        // Float animation for drips
                        ty += Math.sin(Date.now() * 0.002 + i) * 30;
                    }

                    p.x += (tx - p.x) * (p.drip ? 0.01 : ELASTICITY);
                    p.y += (ty - p.y) * (p.drip ? 0.01 : ELASTICITY);
                }
            }

            // Keep Blob Together (Constraints)
            // We only constrain the first POINTS (the main blob), not the drips
            for(let iter=0; iter<4; iter++) {
                for(let i=0; i<POINTS; i++) {
                    let p1 = points[i];
                    let p2 = points[(i+1)%POINTS]; // Next point in ring

                    let dx = p2.x - p1.x;
                    let dy = p2.y - p1.y;
                    let d = Math.hypot(dx, dy);
                    let targetDist = 20; // Approx distance between points
                    
                    // Push/Pull to maintain distance
                    let diff = (targetDist - d) / d * 0.5;
                    let ox = dx * diff;
                    let oy = dy * diff;

                    if(p1 !== dragPoint) { p1.x -= ox; p1.y -= oy; }
                    if(p2 !== dragPoint) { p2.x += ox; p2.y += oy; }
                }
            }
        }

        // --- RENDERING ---

        // We need a flat array to send points to WebGL
        const flatPoints = new Float32Array(TOTAL_POINTS * 2);

        function draw() {
            updatePhysics();

            // 1. Draw WebGL Blob
            gl.viewport(0, 0, width, height);
            
            // Update Uniforms
            gl.uniform2f(resLoc, width, height);
            gl.uniform1f(strLoc, currentStress);

            // Update Point Data
            for(let i=0; i<TOTAL_POINTS; i++) {
                flatPoints[i*2]     = points[i].x;
                flatPoints[i*2 + 1] = points[i].y;
            }
            gl.uniform2fv(ptsLoc, flatPoints);

            // Draw Rect
            gl.drawArrays(gl.TRIANGLES, 0, 6);


            // 2. Draw 2D Face
            uiCtx.clearRect(0, 0, width, height);
            
            // Calculate center for face
            let avgX = 0, avgY = 0;
            for(let i=0; i<POINTS; i++) { avgX += points[i].x; avgY += points[i].y; }
            avgX /= POINTS; avgY /= POINTS;

            const eyeOff = 60;
            const eyeSize = 16 + (currentStress * 12);
            const faceY = avgY - 30;

            uiCtx.fillStyle = '#2D3436';
            uiCtx.strokeStyle = '#2D3436';
            uiCtx.lineWidth = 6;
            uiCtx.lineCap = 'round';

            // Logic for Face Expressions
            if (wobbleTimer > 0) {
                // Dizzy X Eyes
                drawX(avgX - eyeOff, faceY);
                drawX(avgX + eyeOff, faceY);
                // Squiggle Mouth
                uiCtx.beginPath();
                uiCtx.moveTo(avgX - 25, faceY + 50);
                uiCtx.bezierCurveTo(avgX, faceY+20, avgX, faceY+80, avgX + 25, faceY + 50);
                uiCtx.stroke();
            } else if (currentStress > 0.15) {
                // Stressed Eyes
                uiCtx.beginPath();
                uiCtx.ellipse(avgX - eyeOff, faceY, eyeSize, eyeSize + currentStress*20, 0, 0, Math.PI*2);
                uiCtx.ellipse(avgX + eyeOff, faceY, eyeSize, eyeSize + currentStress*20, 0, 0, Math.PI*2);
                uiCtx.fill();
                // O Mouth
                uiCtx.beginPath();
                uiCtx.arc(avgX, faceY + 50, 15 + currentStress*15, 0, Math.PI*2);
                uiCtx.fill();
            } else {
                // Happy Eyes
                uiCtx.beginPath();
                uiCtx.arc(avgX - eyeOff, faceY, 16, 0, Math.PI*2);
                uiCtx.arc(avgX + eyeOff, faceY, 16, 0, Math.PI*2);
                uiCtx.fill();
                // Smile
                uiCtx.beginPath();
                uiCtx.arc(avgX, faceY + 40, 25, 0, Math.PI, false);
                uiCtx.fill();
                // Tongue
                uiCtx.fillStyle = '#FF6B6B';
                uiCtx.beginPath();
                uiCtx.arc(avgX, faceY + 52, 12, 0, Math.PI, false);
                uiCtx.fill();
            }

            requestAnimationFrame(draw);
        }

        function drawX(x, y) {
            const s = 14;
            uiCtx.beginPath();
            uiCtx.moveTo(x-s, y-s); uiCtx.lineTo(x+s, y+s);
            uiCtx.moveTo(x+s, y-s); uiCtx.lineTo(x-s, y+s);
            uiCtx.stroke();
        }


        // --- INPUT HANDLING ---

        function handleStart(x, y) {
            mouseX = x; mouseY = y;
            let bestDist = 100; // Hitbox radius
            
            // Check all points
            for(let p of points) {
                const d = Math.hypot(p.x - x, p.y - y);
                if(d < bestDist) {
                    bestDist = d;
                    dragPoint = p;
                }
            }
            if(dragPoint) {
                isDragging = true;
                wobbleTimer = 0;
            }
        }

        function handleEnd() {
            // Trigger dizzy face if we snap back hard
            if(dragPoint && !dragPoint.drip && currentStress > 0.2) {
                wobbleTimer = 100; // Frames of dizziness
            }
            isDragging = false;
            dragPoint = null;
        }

        // Mouse Events
        window.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY));
        window.addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; });
        window.addEventListener('mouseup', handleEnd);

        // Touch Events (iPad Support)
        window.addEventListener('touchstart', e => {
            e.preventDefault();
            handleStart(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive: false});

        window.addEventListener('touchmove', e => {
            e.preventDefault(); // Stop scrolling
            mouseX = e.touches[0].clientX;
            mouseY = e.touches[0].clientY;
        }, {passive: false});

        window.addEventListener('touchend', handleEnd);

        // Resize
        window.addEventListener('resize', () => {
            glCanvas.width = window.innerWidth;
            glCanvas.height = window.innerHeight;
            uiCanvas.width = window.innerWidth;
            uiCanvas.height = window.innerHeight;
            initPoints();
        });

        // Start
        window.dispatchEvent(new Event('resize'));
        draw();

    </script>
</body>
</html>
